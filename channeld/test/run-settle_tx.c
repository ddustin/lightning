#include "config.h"
#include <inttypes.h>
#include <stdio.h>
#include <common/type_to_string.h>
static bool print_superverbose;
#define SUPERVERBOSE(...)					\
	do { if (print_superverbose) printf(__VA_ARGS__); } while(0)
#define PRINT_ACTUAL_FEE
#include "../commit_tx.c"
#include <bitcoin/tx.h>
#include <bitcoin/psbt.h>
#include <ccan/array_size/array_size.h>
#include <ccan/err/err.h>
#include <ccan/str/hex/hex.h>
#include <common/channel_id.h>
#include <common/key_derive.h>
#include <common/setup.h>
#include <common/status.h>
#include <common/initial_settlement_tx.h>

/* Turn this on to brute-force fee values */
/*#define DEBUG */

/* AUTOGENERATED MOCKS START */
/* Generated stub for fromwire_bigsize */
bigsize_t fromwire_bigsize(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bigsize called!\n"); abort(); }
/* Generated stub for fromwire_channel_id */
bool fromwire_channel_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
			 struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "fromwire_channel_id called!\n"); abort(); }
/* Generated stub for fromwire_node_id */
void fromwire_node_id(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct node_id *id UNNEEDED)
{ fprintf(stderr, "fromwire_node_id called!\n"); abort(); }
/* Generated stub for fromwire_wireaddr */
bool fromwire_wireaddr(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "fromwire_wireaddr called!\n"); abort(); }
/* Generated stub for status_fmt */
void status_fmt(enum log_level level UNNEEDED,
		const struct node_id *peer UNNEEDED,
		const char *fmt UNNEEDED, ...)

{ fprintf(stderr, "status_fmt called!\n"); abort(); }
/* Generated stub for towire_bigsize */
void towire_bigsize(u8 **pptr UNNEEDED, const bigsize_t val UNNEEDED)
{ fprintf(stderr, "towire_bigsize called!\n"); abort(); }
/* Generated stub for towire_channel_id */
void towire_channel_id(u8 **pptr UNNEEDED, const struct channel_id *channel_id UNNEEDED)
{ fprintf(stderr, "towire_channel_id called!\n"); abort(); }
/* Generated stub for towire_node_id */
void towire_node_id(u8 **pptr UNNEEDED, const struct node_id *id UNNEEDED)
{ fprintf(stderr, "towire_node_id called!\n"); abort(); }
/* Generated stub for towire_wireaddr */
void towire_wireaddr(u8 **pptr UNNEEDED, const struct wireaddr *addr UNNEEDED)
{ fprintf(stderr, "towire_wireaddr called!\n"); abort(); }
/* AUTOGENERATED MOCKS END */

char regression_tx_hex[] = "02000000000101bef67e4e2fb9ddeeb3461973cd4c62abb35050b1add772995b820b584a48848900000000002a00000003000000000000000001511027000000000000225120c2f25ad5b139599cceb1ba1b330dfabe3e9298e4d14eec125d229536d532ef781ce80000000000002251202302f780a9d31218dbfd03f4d410ab0803995ed4795dc7963ea105b020de58ab026541d7a72a6c1aac9118078c1855278391dea91c9380a125e71416be15e0573b7eceef11cbdaf40d01c84639e4d1766fa3faa1eb9f4049abe764dc75e62e0b5075e5c1210179be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ac41c1442b558d2430be010fc3aa405a78b81d3c254145fc96dc28f9347e4748cc70a46eb09cb3c07a74993a0c294cfa0b87d5aa9d979f8c4b0e02be2fa561b416d33300000000";

static char *fmt_bitcoin_tx(const tal_t *ctx, const struct bitcoin_tx *tx)
{
    u8 *lin = linearize_tx(ctx, tx);
    char *s = tal_hex(ctx, lin);
    tal_free(lin);
    return s;
}

/* bitcoind loves its backwards txids! */
static struct bitcoin_txid txid_from_hex(const char *hex)
{
	struct bitcoin_txid txid;

	if (!bitcoin_txid_from_hex(hex, strlen(hex), &txid))
		abort();
	return txid;
}

static struct secret secret_from_hex(const char *hex)
{
	struct secret s;
	size_t len;
	if (strstarts(hex, "0x"))
		hex += 2;
	len = strlen(hex);
	/* BOLT #3:
	 *
	 * - Private keys are displayed as 32 bytes plus a trailing 1
	 *   (Bitcoin's convention for "compressed" private keys, i.e. keys
	 *   for which the public key is compressed).
	 */
	if (len == 66 && strends(hex, "01"))
		len -= 2;
	if (!hex_decode(hex, len, &s, sizeof(s)))
		abort();
	return s;
}

static void tx_must_be_eq(const struct bitcoin_tx *a,
			  const struct bitcoin_tx *b)
{
	u8 *lina, *linb;
	size_t i;

	lina = linearize_tx(tmpctx, a);
	linb = linearize_tx(tmpctx, b);

	for (i = 0; i < tal_count(lina); i++) {
		if (i >= tal_count(linb))
			errx(1, "Second tx is truncated:\n"
			     "%s\n"
			     "%s",
			     tal_hex(tmpctx, lina),
			     tal_hex(tmpctx, linb));
		if (lina[i] != linb[i])
			errx(1, "tx differ at offset %zu:\n"
			     "%s\n"
			     "%s",
			     i,
			     tal_hex(tmpctx, lina),
			     tal_hex(tmpctx, linb));
	}
	if (i != tal_count(linb))
		errx(1, "First tx is truncated:\n"
		     "%s\n"
		     "%s",
		     tal_hex(tmpctx, lina),
		     tal_hex(tmpctx, linb));
}

static struct pubkey pubkey_from_hex(const char *hex)
{
    struct pubkey pubkey;

    if (strstarts(hex, "0x"))
        hex += 2;
    if (!pubkey_from_hexstr(hex, strlen(hex), &pubkey))
        abort();
    return pubkey;
}

static int test_initial_settlement_tx(void)
{
    struct bitcoin_outpoint update_output;
    struct amount_sat update_output_sats;
    struct pubkey funding_key[NUM_SIDES];
    u32 shared_delay;
    struct eltoo_keyset eltoo_keyset;
    struct amount_sat dust_limit;
    struct amount_msat self_pay;
    struct amount_msat other_pay;
    struct amount_sat self_reserve;
    u32 obscured_update_number;
    /* struct wally_tx_output direct_outputs[NUM_SIDES]; Can't figure out how it's used */
    char* err_reason;
    struct bitcoin_tx *tx, *tx_cmp;
    struct privkey alice_funding_privkey, bob_funding_privkey, alice_settle_privkey, bob_settle_privkey;
    int ok;
    char *tx_hex;
    char *psbt_b64;

    /* Test initial settlement tx */

    update_output.txid = txid_from_hex("8984484a580b825b9972d7adb15050b3ab624ccd731946b3eeddb92f4e7ef6be");
    update_output.n = 0;
    update_output_sats.satoshis = 69420;
    funding_key[0] = pubkey_from_hex("02fcba7ecf41bc7e1be4ee122d9d22e3333671eb0a3a87b5cdf099d59874e1940f");

    alice_funding_privkey.secret = secret_from_hex("30ff4956bbdd3222d44cc5e8a1261dab1e07957bdac5ae88fe3261ef321f374901");
    bob_funding_privkey.secret = secret_from_hex("1552dfba4f6cf29a62a0af13c8d6981d36d0ef8d61ba10fb0fe90da7634d7e1301");

    ok = pubkey_from_privkey(&alice_funding_privkey,
             &funding_key[0]);
    ok = pubkey_from_privkey(&bob_funding_privkey,
             &funding_key[1]);

    shared_delay = 42;

    alice_settle_privkey.secret = secret_from_hex("1111111111111111111111111111111111111111111111111111111111111111");
    bob_settle_privkey.secret = secret_from_hex("2222222222222222222222222222222222222222222222222222222222222222");

    ok = pubkey_from_privkey(&alice_settle_privkey,
             &eltoo_keyset.self_settle_key);
    ok = pubkey_from_privkey(&bob_settle_privkey,
             &eltoo_keyset.other_settle_key);
    assert(ok);

    dust_limit.satoshis = 294;
    self_pay.millisatoshis = (update_output_sats.satoshis - 10000)*1000;
    other_pay.millisatoshis = (update_output_sats.satoshis*1000) - self_pay.millisatoshis;
    self_reserve.satoshis = 0; /* not testing this yet since it's really layer violation here */
    obscured_update_number = 0; /* non-0 mask not allowed currently, this should always be 0 */

    tx = initial_settlement_tx(tmpctx,
                     &update_output,
                     update_output_sats,
                     funding_key,
                     shared_delay,
                     &eltoo_keyset,
                     dust_limit,
                     self_pay,
                     other_pay,
                     self_reserve,
                     obscured_update_number,
                     /* direct_outputs FIXME Cannot figure out how this is used. */ NULL,
                     &err_reason);

    tx_hex = fmt_bitcoin_tx(tmpctx, tx);
    printf("Settlement tx: %s\n", tx_hex);
    psbt_b64 = psbt_to_b64(tmpctx, tx->psbt);
    printf("Settlement psbt: %s\n", psbt_b64);

    /* Regression test vector for now */
    tx_cmp = bitcoin_tx_from_hex(tmpctx, regression_tx_hex, sizeof(regression_tx_hex)-1);
    tx_must_be_eq(tx, tx_cmp);


	return 0;
}

int main(int argc, const char *argv[])
{
    int err = 0;

	common_setup(argv[0]);

    chainparams = chainparams_for_network("bitcoin");

    err |= test_initial_settlement_tx();
    assert(!err);

	common_shutdown();

    return err;
}

